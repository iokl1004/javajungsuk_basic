ch7-1 상속(Inheritance)
- 기존의 클래스로 새로운 클래스를 작성하는 것.(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것.
class 자식클래스 extends 부모클래스 {
	// ...
}

class Parent { }
class Child extends Parent {
	// ...
}

- 자손은 조상의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)
- 자손의 멤버 개수는 조상보다 적을 수 없다.(같거나 많다.)

class Parent {
	int age;	//멤버 1개
}

class Child( 자식 ) extends Parent( 부모 ) { // ( 멤버 1 개)
	void play() {	//새로운 멤버 추가
		System.out.println("놀자~");
	}
}
Chile 클래스의 멤버는 총 2개다. ( 자신 멤버 1개, 상속받은 멤버 1개 )

class Point {	//2차원 좌표의 한 점
	int x;
	int y;
}

//3차원 좌표를 만들고 싶다면 아래 처럼 만들수 있지만
//Point 클래스에서 변경을 해도 아무런 지장이 없다!
class Point3D {
	int x;
	int y;
	int z;
}
//상속을 통해 받을수있다!
//Point 클래스에서 변경을 하면 지장이 생긴다
class Point3D extends Point {
	int z;
}
-----------------------------------------------------------------------------
ch7-2 상속(Inheritance) (예제)
-----------------------------------------------------------------------------
ch7-3 포함 관계
포함(composite) 이란?
 - 클래스의 멤버로 참조변수를 선언하는것
 - 작은 단위의 클래스를 만들고, 이 들을 조합해서 클래스를 만든다.
class Circle {
	int x;	//원점의 x좌표
	int y;	//원점의 y좌표
	int r;	//반지름
}

class Circle {
	Point c = new Point();	//원점
	int r;	//반지름
}

class Point {
	int x;
	int y;
}

class Car {
	Engine e = new Engine();	//엔진
	Door[] d = new Door[4];	//문, 문의 개수를 넷으로 가정하고 배열로 처리햇다.
	// ...
}
-----------------------------------------------------------------------------
ch7-4 클래스 간의 관계 결정하기
상속관계 '~은~이다.(is-a)'
포함관계 '~은~을 가지고 있다.(has-a)'
대부분의 90%관계는 포함관계다.

1. 포함관계 ( O )
class Circle {
	Point c = new Point();
	int r;
}

2. 상속관계 ( X )
class Circle extends Point {
	int r;
}

class Point {
	int x;
	int y;
}

원(Circle)은 점(Point)이다. 상속관계 ( X ) 
원(Circle)은 점(Point)을 가지고 있다. 포함관계 ( O )
-----------------------------------------------------------------------------
ch7-5 단일 상속(Single Inheritance)
- java는 단일상속만을 허용한다. (C++은 다중상속 허용)
	class TvDVD extends Tv, DVD {	//에러!! 조상은 하나만 허용된다.
		//...
	}
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함 관계로 한다.
-----------------------------------------------------------------------------
ch7-6 Object클래스 - 모든 클래스의 조상
- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.
- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다.
toString(), equals(Object obj), hashCode(), ...

class Tv (extends Object){
	//...
}

class SamrtTv extends Tv {
	//...
}
-----------------------------------------------------------------------------
ch7-7 오버라이딩(overriding)
- 상속받은 조상의 메서드를 자신에 맞게 변경하는 것
class Point {
	int x;
	int y;

	String getLocation() {
		return "x :" + x + ", y :" + y;
	}
}

class Pint3D extends Point {
	int z;

	String getLocation() {	//오버라딩
		return "x :" + x + ", y :" + y + ", z :" + z;
	}
}
-----------------------------------------------------------------------------
ch7-8 오버라이딩의 조건
1. 선언부가 조상 클래스의 메서드와 일치해야한다.
2. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.

	class Parent {
		void parentMethod() throws IOException, SQLException {
			...
		}
	}

	class Child extends Parent {
		void parentMethod() throws IOEXception {
			...
		}
	}
-----------------------------------------------------------------------------
ch7-9 오버로딩 vs 오버라이딩
근본적으로 둘의 관계는 상관없다

오버로딩(overloading) : 기존에 없는 새로운 메서드를 정의하는 것(new) / 상속하고 관계가 없음
오버라이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify) / 상속하고 관계가 있음!! 상속받은걸 변경하는거니까!

class Parent {
	void parentMethod() {}
}

class Chile extends Parent {
	void parentMethod() {}	//오버라이딩
	void parentMethod(int i) {}	// 오버로딩

	void childMethod() {}	// 메서드 정의
	void childMethod(int i) {}	//오버로딩
	void childMethod() {}	// 중복정의 이건안됌;;
}
-----------------------------------------------------------------------------
ch7-10 참조변수 super ( ※ this는 lv와 iv 구별에 사용 )
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에만 존재
- 조상의 멤버를 자신의 멤버와 구별할 때 사용
-----------------------------------------------------------------------------
ch7-11 super() - 조상의 생성자
- 조상의 생성자를 호출할때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화
class Point {
	int x, y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
}

class Point3D extends Point {
	int z;

	Point3D(int x, int y, int z) {
		super.x = x; //조상의 멤버를 초기화
		this.y = y; //자신의 멤버를 초기화
		this.z = z;
	}
}

- 생성자의 첫 줄에 반드시 생성자를 호출해야 한다. ( 상당히 중요!!! )
  그렇지 않으면 컴파일러가 생성자의 첫 줄에 super(); 삽입
class Point {
	int x;
	int y;

	Point() {
		this(0,0);	//this 호출했으니 OK!
	}

	Point(int x, int y) {
		this.x = x;		//생성자가 없어......?
		this.y = y;
	}
}
class Point extends Object {
	int x;
	int y;

	Point() {
		this(0,0);
	}

	Point(int x, int y) {
		super();	//Object();
		this.x = x;
		this.y = y;
	}
}
-----------------------------------------------------------------------------
ch7-12 패키지(package)
- 서로 관련된 클래스의 묶음 (java8 기준 약 4000개 클래스가 있음)
- 클래스는 클래스 파일(*.class) 패키지는 폴더. 하위 패키지는 하위 폴더
- 클래스의 실제 이름(full name)은 패키지를 포함.(java.lang.String)
  rt.jar는 클래스들을 압축한 파일(JDK설치경로\jre\lib에 위치)
( ※ java 9부터는 rt.jar 파일이 없으며, 모듈로 되었다고함. )
-----------------------------------------------------------------------------
ch7-13 패키지의 선언
- 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
- 같은 소스파일의 클래스들은 모두 같은 패키지에 속하게 된다.
- 패키지 선언이 없으 면 이름없는(unnamed) 패키지에 속하게 된다.

package com.codechobo.book;

public class PackageTest {
	public static void main(String[] args) {
		System.out.println("Hello, world!");
	}
}

class PackageTest2 { }
-----------------------------------------------------------------------------
ch7-14 클래스 패스(classpath)
- 클래스 파일(*.class)의 위치를 알려주는 경로(path)
- 환경변수 classpath로 관리하며, 경로간의 구분자는 ';'를 사용
  classpath(환경변수)에 패키지의 루트를 등록해줘야 함.
-----------------------------------------------------------------------------
ch7-15 import문
- 클래스를 사용할 때 패키지이름을 생략할 수 있다.
- 컴파일러에게 클래스가 속한 패키지를 알려준다. ( 이클립스 단축키 ctrl + shift + O )
- java.lang 패지키의 클래스는 import하지 않고도 사용할 수 있다.
  String, Object, System, Thread ...
- import문을 선언하는 방법은 다음과 같다.
 import 패키지명.클래스명; 또는 import 패키지명.*;
- import문은 패키지문과 클래스선언의 사이에 선언한다.
- import문은 컴파일 시에 처리되므로 프로그램의 성능에 영향없음.
- 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야한다.
-----------------------------------------------------------------------------
ch7-16 static import문
- static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.
- static멤버를 왜 사용하냐면 나중에 가면 갈수록, 클래스 이름을 붙히면 코드가 너무 길어져서 코드를 간결하게 만들수있음
- 단 필요할때만 사용하는걸 추천!

import static java.lang.Integer.*;	//Integer클래스의 모든 static 메서드
import static java.lang.Math.reandom;	//Math.random()만. 괄호 안붙임.
import static java.lang.System.out;	//System.out을 out만으로 참조가능
-----------------------------------------------------------------------------
ch7-17 제어자(modifier)
- 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여

접근 제어자 public, protected, (default), private
그	외 static, final, abstract, native, transient, sysnchronized, volatile, strictfp

- 하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만)

public class ModifierTest {
	public static final int WIDTH = 200;

	public static void main(String[] args) {
		System.out.println("WIDTH="+WIDTH);
	}
}
-----------------------------------------------------------------------------
ch7-18 static - 클래스의, 공통적인

static - 멤버변수 - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
	          - 클래스 변수는 인스턴스를 생성하지 않고도 사용가능하다.
	          - 클래스가 메모리에 로드될 때 생성된다.
        - 메서드    - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
	          - static메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.

class Static Test {
	static int width = 200;	// 클래스 변수( static변수 )
	static int height = 120;	// 클래스 변수 ( static 변수 )

	static {			// 클래스 초기화 블럭
		// static변수의 복잡한 초기화 수행
	}

	static int max(int a, int b)	{	//클래스 메서드(static 메서드)
		return a > b ? a : b;
	}
}
-----------------------------------------------------------------------------
ch7-19 final - 마지막의, 변경될 수 없는

final - 클래스 - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다. 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
       - 메서드 - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
       - 멤버변수, 지역변수 - 값을 변경할 수 없는 상수가 된다.

final class FinalTest {	//조상이 될수 없는 클래스
	final int MAX_SIZE = 10;	//  값을 변경할 수 없는 멤버변수(상수)

	final void getMaxSize() {	//오버라이딩할 수없는 메서드(변경불가), 오버라이딩 : 조상 메서드를 덮어쓰는것
		final int LV = MAX_SIZE;	//값을 변경할 수 없는 지역변수(상수)
		return MAX_SIZE;
	}
}
-----------------------------------------------------------------------------
ch7-20 abstract - 추상의, 미완성의

abstract - 클래스 - 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
           - 메서드 - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.

abstract class AbstractTest {	// 추상 클래스 ( 추상 메서드를 포함한 클래스 )
	abstract void move();	//추상 메서드 ( 구현부가 없는 메서드 ), 보면 몸통만 가지고 있음.
}

AbstractTest a = new AbstractTest();	// 에러. 추상 클래스의 인스턴스 생성불가

미완성 클래스가 무슨뜻이냐면 추상메서드가 있다면 무조건 추상클래스이다.
추상 클래스는 한마디로 미완성 설계도이다!
미완성 설계도면 제품 생성 불가! 즉, 객체를 만들수가 없다.
추상메서드는 몸통밖에 없는 메서드
-----------------------------------------------------------------------------
ch7-21 접근 제어자(access modifier)
private 같은 클래스 내에서만 접근이 가능하다.
(default) 같은 패키지 내에서만 접근이 가능하다.
protected 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.
public 접근 제한이 전혀 없다.

public(접근제한 없음) > protected(같은 패키지+자손) > (default) (같은패키지) > private (같은 클래스)
-----------------------------------------------------------------------------
ch7-22 캡슐화와 접근 제어자
접근 제어자를 사용하는 이유
 - 외부로부터 데이터를 보호하기 위해서
 - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

public class Time {
	public int hour;
	public int minute;
	public int second;
}

Time t = new Time();
t.hour = 25;	//멤버변수에 직접 접근

위에서 변경을 한다면...? 
접근 제어자를 이용한 캡슐화
public class Time {
	private int hours; // 접근 제어자를 private으로 하여 외부에서 직접 접근하지 못하도록 한다. 
	private int minute; // private는 같은 클래스 내에서만 접근이 가능하다.
	private int second;

	public int getHour() { return hour; }
	public void setHour(int hour) {
		if (hour < 0 || hour > 23) return;
		this.hour = hour;
	}
}
-----------------------------------------------------------------------------
ch7-23 다형성 (polymorphism)
※ 다형성을 이해하지 못하면 뒤에 진도 이해를 못하므로, 인지..
- 여러 가지 형태를 가질 수 있는 능력
- 다형성 뭐냐? 조상 타입 참조 변수로 자손 타입 객체를 다루는 것

	Tv t = new SmartTv();	// 타입(불일치) OK
	Tv ( 조상 ), SmartTv ( 자손 )
class Tv {
	boolean power;	//전원상태(on/off)
	int channel;	//채널

	void power()	{ power = !power; }
	void channelUp()	{ ++channel; }
	void channelDown()	{ --channel; }
}

class SmartTv extends Tv {
	String test;	//캡션(자막)을 보여주기 위한 문자열
	void caption()	{ /* 내용생략 */ }
}

- 객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?

SmartTv s = new SmartTv();	//참조 변수와 인스턴스의 타입이 일치
Tv         t = new SmartTv();	//조상 타입 참조변수로 자손 타입 인스턴스 참조

- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.
	Tv	t = new SmartTv();	//OK. 허용
	SmartTv 	s = new Tv();	//에러. 허용 안 됨.

조상 t 5개 < 자손 SmartTv 7개 OK
자손 s 7개 < 조상 Tv 5개 //에러
왜 안되냐면 실제 사용할수있는것보다 리모콘 버튼개수가 많으면 안된다.
없는걸 호출할수 있기때문에

Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치해야 하나요?
A. 아닙니다. 일치하는 것이 보통이지만 일치 하지 않을 수도 있습니다.

SmartTv s = new SmartTv();	// 참조 변수와 인스턴스의 타입이 일치
Tv	t = new SmartTv();	// 조상 타입 참조변수로 자손 타입 인스턴스 참조
조상		자손	//불일치 다형성

Q. 참조변수가 조상타입일 때와 자손타입일 때의 차이?
A. 참조변수로 사용할 수 잇는 멤버의 갯수가 달라집니다.

Q. 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 있나요?
A. 아니요. 허용되지 않습니다.

Tv	t = new SmartTv();	//OK. 허용, 7개를 5개로 줄이는건 가능
SmartTv s = new Tv();	//에러. 허용 안 됨, 5개를 7개로 늘리는건 안됨
-----------------------------------------------------------------------------
ch7-24 참조변수의 형변환
- 사용할 수 있는 멤버의 갯수를 조절하는 것
- 조상, 자손, 관계의 참조변수는 서로 형변환 가능

FireEngine f = new FireEngine();

Car c = (Car)f;	//OK. 조상인 Car타입으로 형변환(생략가능)
FireEngine f2 = (FireEngine)c;	//OK. 자손인 FireEngine타입으로 형변환(생략불가)
Ambulance a = (Ambulance)f;	//에러. 상속관계가 아닌 클래스 간의 형변환 불가

class Car { }
class FireEngine extends Car { }
class Ambulance extends Car { }

class Car {
	String color;
	int door;

	void drive() {	//운전하는 기능
		System.out.println("driver, Brrrr~");
	}

	void stop() {
		System.out.println("driver Stop!");
	}
}

class FireEngine extends Car {	//소방차
	void water() {
		System.out.println("Water!!!");
	}
}
-----------------------------------------------------------------------------
ch7-25 참조변수의 형변환(2) (예제)
-----------------------------------------------------------------------------
ch7-26 instanceof 연산자
- 참조변수의 형변환 가능 여부 확인에 사용. 가능하면 true 반환
- 형변환 전에 반드시 instanceof로 확인해야 함
void doWork(Car  c) {
	if (c instanceof FireEngine) {	//1. 형변환이 가능한지 확인
		FireEngine fe = (FireEngine)c; // 2. 형변환
		fe.water();
		...

형변환을 하는 이유는 인스턴스의 원래 기능을 모두 사용하려고.
Car 타입의 리모콘인 c로는 water()를 호출할 수 없으니까.
리모콘을 FireEngine타입으로 바꿔서 water()를 호출

FireEngine fe = new FireEngine();
System.out.println(fe instanceof Object);	//true
System.out.println(fe instanceof Car);		//true
System.out.println(fe instanceof FireEngine);	//true

Object obj = (Object)fe;	// OK
Car	c = (Car)fe;	//OK

Q. 참조변수의 형변환은 왜 하나요?
A. 참조변수(리모콘)을 변경함으로써 사용할 수 있는 멤버의 갯수를 조절하기 위해서
FireEngine f = new FireEngine();
Car c = (Car)f;	//OK. 조상인 Car타입으로 형변환(생략가능)

Q. instanceof연산자는 언제 사용하나요?
A. 참조변수를 형변환하기 전에 형변환 가능여부를 확인할때
void doWork(Car  c) {
	if (c instanceof FireEngine) {	//1. 형변환이 가능한지 확인
		FireEngine fe = (FireEngine)c; // 2. 형변환
		fe.water();
		...
-----------------------------------------------------------------------------
ch7-27 매개변수의 다형성
- 참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.
- 장점 : 1. 다형적 매개변수, 2. 하나의 배열로 여러종류 객체다루기

다형성 ① Tv t (조상) = new SmartTv(); (자손)
          ② 참조변수의 형변환 - 리모콘 바꾸기, 사용가능한 멤버갯수로 조절
          ③ instanceof연산자 (형변환 가능여부 확인)

class Product {
	int price;	// 제품가격
	int bonusPoint;	//보너스 점수
}

class Tv extends Product {}
class Computer extends Product {}
class Audio extends Product {}

class Buyer {	//물건사는 사람
	int money = 1000;	//소유금액
	int bonusPoint = 0;	//보너스 점수
}

void buy(Product p) {
	money -= p.price;
	bonusPoint += p.bonusPoint;
}
-----------------------------------------------------------------------------
ch7-28 매개변수의 다형성 (예제)
-----------------------------------------------------------------------------