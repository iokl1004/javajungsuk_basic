ch7-1 상속(Inheritance)
- 기존의 클래스로 새로운 클래스를 작성하는 것.(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것.
class 자식클래스 extends 부모클래스 {
	// ...
}

class Parent { }
class Child extends Parent {
	// ...
}

- 자손은 조상의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)
- 자손의 멤버 개수는 조상보다 적을 수 없다.(같거나 많다.)

class Parent {
	int age;	//멤버 1개
}

class Child( 자식 ) extends Parent( 부모 ) { // ( 멤버 1 개)
	void play() {	//새로운 멤버 추가
		System.out.println("놀자~");
	}
}
Chile 클래스의 멤버는 총 2개다. ( 자신 멤버 1개, 상속받은 멤버 1개 )

class Point {	//2차원 좌표의 한 점
	int x;
	int y;
}

//3차원 좌표를 만들고 싶다면 아래 처럼 만들수 있지만
//Point 클래스에서 변경을 해도 아무런 지장이 없다!
class Point3D {
	int x;
	int y;
	int z;
}
//상속을 통해 받을수있다!
//Point 클래스에서 변경을 하면 지장이 생긴다
class Point3D extends Point {
	int z;
}
-----------------------------------------------------------------------------
ch7-2 상속(Inheritance) (예제)
-----------------------------------------------------------------------------
ch7-3 포함 관계
포함(composite) 이란?
 - 클래스의 멤버로 참조변수를 선언하는것
 - 작은 단위의 클래스를 만들고, 이 들을 조합해서 클래스를 만든다.
class Circle {
	int x;	//원점의 x좌표
	int y;	//원점의 y좌표
	int r;	//반지름
}

class Circle {
	Point c = new Point();	//원점
	int r;	//반지름
}

class Point {
	int x;
	int y;
}

class Car {
	Engine e = new Engine();	//엔진
	Door[] d = new Door[4];	//문, 문의 개수를 넷으로 가정하고 배열로 처리햇다.
	// ...
}
-----------------------------------------------------------------------------
ch7-4 클래스 간의 관계 결정하기
상속관계 '~은~이다.(is-a)'
포함관계 '~은~을 가지고 있다.(has-a)'
대부분의 90%관계는 포함관계다.

1. 포함관계 ( O )
class Circle {
	Point c = new Point();
	int r;
}

2. 상속관계 ( X )
class Circle extends Point {
	int r;
}

class Point {
	int x;
	int y;
}

원(Circle)은 점(Point)이다. 상속관계 ( X ) 
원(Circle)은 점(Point)을 가지고 있다. 포함관계 ( O )
-----------------------------------------------------------------------------
ch7-5 단일 상속(Single Inheritance)
- java는 단일상속만을 허용한다. (C++은 다중상속 허용)
	class TvDVD extends Tv, DVD {	//에러!! 조상은 하나만 허용된다.
		//...
	}
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함 관계로 한다.
-----------------------------------------------------------------------------
ch7-6 Object클래스 - 모든 클래스의 조상
- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.
- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다.
toString(), equals(Object obj), hashCode(), ...

class Tv (extends Object){
	//...
}

class SamrtTv extends Tv {
	//...
}
-----------------------------------------------------------------------------
ch7-7 오버라이딩(overriding)
- 상속받은 조상의 메서드를 자신에 맞게 변경하는 것
class Point {
	int x;
	int y;

	String getLocation() {
		return "x :" + x + ", y :" + y;
	}
}

class Pint3D extends Point {
	int z;

	String getLocation() {	//오버라딩
		return "x :" + x + ", y :" + y + ", z :" + z;
	}
}
-----------------------------------------------------------------------------
ch7-8 오버라이딩의 조건
1. 선언부가 조상 클래스의 메서드와 일치해야한다.
2. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.

	class Parent {
		void parentMethod() throws IOException, SQLException {
			...
		}
	}

	class Child extends Parent {
		void parentMethod() throws IOEXception {
			...
		}
	}
-----------------------------------------------------------------------------
ch7-9 오버로딩 vs 오버라이딩
근본적으로 둘의 관계는 상관없다

오버로딩(overloading) : 기존에 없는 새로운 메서드를 정의하는 것(new) / 상속하고 관계가 없음
오버라이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify) / 상속하고 관계가 있음!! 상속받은걸 변경하는거니까!

class Parent {
	void parentMethod() {}
}

class Chile extends Parent {
	void parentMethod() {}	//오버라이딩
	void parentMethod(int i) {}	// 오버로딩

	void childMethod() {}	// 메서드 정의
	void childMethod(int i) {}	//오버로딩
	void childMethod() {}	// 중복정의 이건안됌;;
}
-----------------------------------------------------------------------------
ch7-10 참조변수 super ( ※ this는 lv와 iv 구별에 사용 )
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에만 존재
- 조상의 멤버를 자신의 멤버와 구별할 때 사용
-----------------------------------------------------------------------------
ch7-11 super() - 조상의 생성자
- 조상의 생성자를 호출할때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화
class Point {
	int x, y;

	Point(int x, int y) {
		this.x = x;
		this.y = y;
	}
}

class Point3D extends Point {
	int z;

	Point3D(int x, int y, int z) {
		super.x = x; //조상의 멤버를 초기화
		this.y = y; //자신의 멤버를 초기화
		this.z = z;
	}
}

- 생성자의 첫 줄에 반드시 생성자를 호출해야 한다. ( 상당히 중요!!! )
  그렇지 않으면 컴파일러가 생성자의 첫 줄에 super(); 삽입
class Point {
	int x;
	int y;

	Point() {
		this(0,0);	//this 호출했으니 OK!
	}

	Point(int x, int y) {
		this.x = x;		//생성자가 없어......?
		this.y = y;
	}
}
class Point extends Object {
	int x;
	int y;

	Point() {
		this(0,0);
	}

	Point(int x, int y) {
		super();	//Object();
		this.x = x;
		this.y = y;
	}
}