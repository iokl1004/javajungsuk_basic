ch11-1 컬렉션 프레임웍(Collections Framework)
- 컬렉션(Collection) : 여러 객체(데이터)를 모아 놓은 것을 의미
- 프레임웍(framework) : frame 틀, work 작업 / 표준화, 정형화된 체계적인 프로그래밍 방식
- 컬렉션 프레임웍(Collections Framework) 
컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식
컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공
java.util패키지에 포함. JDK1.2부터 제공
-----------------------------------------------------------------------------
ch11-2 컬렉션 프레임웍의 핵심 인터페이스

인터페이스	특징
List		순서가 있는 데이터의 집합. 데이터의 중복을 허용한다.
		예) 대기자 명단
		구현 클래스 : ArrayList, LinkedList, Stack, Vector등

Set		순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
		예) 양의 정수 집합, 소수의 집합
		구현 클래스 : HashSet, TreeSet등

Map		키(Key)와 값(Value)의 쌍(Pair)으로 이루어진 데이터의 집합 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
		예) 우편번호, 지역번호(전화번호)
		구현 클래스 : HashMap, TreeMap, Hashtable, Properties 등
-----------------------------------------------------------------------------
ch11-3 Collection 인터페이스의 메서드
1. List : 순서O, 중복O
2. Set : 순서X, 중복X
3. Map : 순서X 중복(키X, 값O)

List와 Set의 공통부분은 Collection

메서드				설명
boolean add(Object o)		지정된 객체(o) 또는 Collection(c)의 객체들을 Collection에
boolean AddAll(Coleection c)		추가한다.

void clear()			Collection의 모든 객체를 삭제한다.

boolean contains(Object o)		지정된 객체(o)또는 Collection의 객체들이 Collection에 포함되어
boolean containsAll(Collection c)	있는지 확인한다.

boolean equals(Object o)		동일한 Collection인지 비교한다.
int hashCode()			Collection의 hash code를 반환한다.
boolean isEmpty()			Collection이 비어있는지 확인한다.
lterator lterator(Object o)		Collection의 lterator를 얻어서 반환한다.

boolean remove(Object o)		지정된 객체를 삭제한다.
boolean removeAll(Collection c)	지정된 Collection에 포함된 객체들을 삭제한다.

boolean retainAll(Collection c)	지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제한다.
				이 작업으로 인해 Collection에 변화가 잇으면 true를 그렇지 않으면 false를 반환한다.

int size()				Collection에 저장된 객체의 개수를 반환한다.
Objecet[] toArrat()			Collection에 저장된 객체를 객체배열(Object[])로 반환한다.
Objecet[] toArrat(Object[]a)		지정된 배열에 Collection의 객체를 저장해서 반환한다.
-----------------------------------------------------------------------------
ch11-4 List인터페이스 - 순서O, 중복O
	List
Vector / ArrayList / LinkedList
Stack

ArrayList, LinkedList가 진또배기이며 핵심!!! 잘 알아두자

<그림 ch11-4-1 참고>
-----------------------------------------------------------------------------
ch11-5 SET인터페이스 - 순서X, 중복 X
	Set
HashSEt	SortedSet
	TreeSEt

HashSet, TreeSet 이 핵심!

* Set인터페이스의 메서드 - Collection인터페이스와 동일
<그림 ch11-5-1 참고>

* 집합과 관련된 메서드(Collection에 변화가 있으며 true, 아니면 false를 반환)
<그림 ch11-5-1 참고>
-----------------------------------------------------------------------------
ch11-6 Map인터페이스 - 순서X, 중복(키X, 값O)
		Map
Hashtable	HashMap		SortedMap
		LinkedHashMap	TreeMap

핵심은 HashMap, TreeMap이 핵심!
Hashtable은 옛날버전이고 HashMap은 최신버전!
Hashtable은 동기화가 되어있고, HashMap은 동기화가 안되어있지만, 동기화를 처리할수있는 기능이 있음.

Map인터페이스의 메서드
<그림 ch11-6-1 참고>
-----------------------------------------------------------------------------
ch11-7 ArrayList
- ArrayList는 기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일
   ArrayList와 달리 Vector는 자체적으로 동기화처리가 되어 있다.
- List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- 데이터의 저장공간으로 배열을 사용한다.(배열기반)

	   List
Cevtor	ArrayList	LinkedList
Stack
-----------------------------------------------------------------------------
ch11-8 ArrayList의 메서드
<그림 ch11-8-1 참고>
-----------------------------------------------------------------------------
ch11-9 ArrayList의 메서드 (예제)
-----------------------------------------------------------------------------
ch11-10 ArrayList에 저장된 객체의 삭제과정
- ArrayList에 저장된 세 번째 데이터(data[2])를 삭제하는 과정. list.remove(2);를 호출
① 삭제할 데이터 아래의 데이터를 한 칸씩 위로 복사해서 삭제할 데이터를 덮어쓴다.

② 데이터가 모두 한 칸씩 이동했으므로 마지막 데이터는 null로 변경한다.
	data[size-1] = null;

③ 데이터가 삭제되어 데이터의 갯수가 줄었으므로 size의 값을 감소시킨다.
	size--;
※ 마지막 데이터를 삭제하는 경우, ①의 과정 (배열의 복사)은 필요없다.
<그림 ch11-10-1 참고>

- ArrayList에 저장된 첫 번째 객체부터, 삭제하는 경우(배열 복사 발생)
<그림 ch11-10-2 참고>

- ArrayList에 저장된 마지막 객체부터 삭제하는 경우(배열 복사 발생안함) (빠름)
<그림 ch11-10-3 참고>
-----------------------------------------------------------------------------
ch11-12 LinkedList - 배열의 장단점
장점 : 배열은 구조가 간단하고 데이터를 읽는 데 걸리는 시간 ( 접근시간, access time)이 짧다.

단점 1 : 크기를 변경할 수 없다.
- 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야함.
- 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨.

단점 2 : 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
- 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.
- 그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다.

ch11-12 LinkedList - 배열의 단점을 보완 ( 크기변경안되고, 추가삭제시간이 많이 걸린다.)
- 배열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결(link)

- 데이터의 삭제 : 단 한 번의 참조변경만으로 가능
<그림 ch11-12-1 참고>

- 데이터의 추가 : 한번의 Node객체생성과 두 번의 참조변경만으로 가능
<그림 ch11-12-1 참고>

3.2 LinkedList - 이중 연결 리스트
- 링크드 리스트(linked list) : 연결리스트. 데이터 접근성이 나쁨
<그림 ch11-12-2 참고>

- 더블리 링크드 리스트(doubly linked list) - 이중 연결리스트, 접근성 향상
<그림 ch11-12-2 참고>

- 더블리 써큘러 링크드 리스트(doubly circular linked list) - 이중 원형 연결리스트
<그림 ch11-12-2 참고>

3.3 ArrayList vs LinkedList - 성능 비교
① 순차적으로 데이터를 추가/삭제 - ArrayList가 빠름
② 비순차적으로 데이터를 추가/삭제 - LinkedList가 빠름
③ 접근시간(access time) - ArrayList가 빠름
	인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기

컬렉션		읽기(접근시간)	추가/삭제		비고
ArrayList		빠르다		느리다		순차적인 추가삭제는 더 빠름. 비효율적인 메모리 사용(성능이 좋아서, 배열을 크게 잡기때문)
LinkedList 	느리다		빠르다		데이터가 많을수록 접근성이 떨어짐 (하나씩 이동해서 가야하기때문에..)

ArrayList 배열기반 ( 연속적 ) , LinkedList 연결기반 ( 불연속적 )
-----------------------------------------------------------------------------
ch11-15 스택과 큐(Stack & Queue)
- 스택(Stack) : LIFO구조, 마지막에 저장된 것을 제일먼저 꺼내게 된다. ( Last In First Out ), 저장 ( push ), 추출 ( pop )
- 큐(Queue) : FIFO구조, 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다. 저장 ( offer ), 추출 ( poll )
-----------------------------------------------------------------------------
ch11-16 스택과 큐(Stack & Queue)의 메서드

스택
메서드			설명
boolean empty()		Stack이 비어있는지 알려준다.
Object peek()		Stack 맨 위에 저장된 객체를 반환. pop()과 달리 Stack에서 객체를 꺼내지는 않음.(비었을 때는 EmptyStackException 발생)
Object pop()		Stack의 맨 위에 저장된 객체를 꺼낸다. (비었을 때는 EmptyStackException 발생)
Object push(Object item)	Stack에 객체(item)을 저장한다.
int search(Object o)	Stack에서 주어진 객체(o)를 찾아서 그 위치를 반환. 못찾으면 -1을 반환. (배열과 달리 위치는 0이 아닌 1부터 시작)

큐
메서드			설명
booelan add(Object o)	지정된 객체를 Queue에 추가한다. 성공하면 true를 반환. 저장공간이 부족하면 lilegaStateException발생
Object remove()		Queue에서 객체를 꺼내 반환. 비어있으면 NoSuchElementException발생
Object element()		삭제없이 요소를 읽어온다. peek와 달리 Queue가 비었을 때 NoSuchElementException발생
boolean offer(Object o)	Queue에 객체를 저장, 성공하면 true, 실패하면 false를 반환
Object poll()		Queue에서 객체를 꺼내서 반환, 비어있으면 null을 반환
Object peek()		삭제없이 요소를 읽어 온다. Queue가 비어있으며 null을 반환

add, remove, element는 예외발생! offer, pool, peek은 예외발생 안함!
-----------------------------------------------------------------------------
ch11-17 없음.....
-----------------------------------------------------------------------------
ch11-18 인터페이스를 구현한 클래스 찾기 (예제)
-----------------------------------------------------------------------------
ch11-19 스택과 큐(Stack & Queue)의 활용
스택의 활용 예 - 수식계산, 수식괄호검사, 워드프로세스의 undo/redo, 웹브라우저의 뒤로 앞으로
큐의 활용 예 - 최근사용문서, 인 쇄작업 대기목록, 버퍼
-----------------------------------------------------------------------------
ch11-20~21 스택과 큐(Stack & Queue)의 활용 (예제)
-----------------------------------------------------------------------------
ch11-22 Iterator, ListIterator, Enumeration
- 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스
- Enumeration은 Iterator의 구버젼
- ListIterator는 Iterator의 접근성을 향상시킨 것 (단방향 → 양방향)
- 메서드 <그림 ch11-22-1 참고>

- 컬렉션에 저장된 저장된 요소들을 읽어오는 방법을 표준화한 것
- 컬렉션에 iterator()를 호출해서 Iterator를 구현한 객체를 얻어서 사용.

	List list = new ArrayList();	//다른 컬렉션으로 변경할 때는 이 부분만 고치면 된다.\
	Iterator it = list.iterator();

	while(it.hasNext())	//bollean hasNext, 읽어올 요소가 있는지 확인
		System.out.println(it.next());
	}
-----------------------------------------------------------------------------
ch11-23 Iterator, ListIterator, Enumeration (예제)
-----------------------------------------------------------------------------
ch11-24 Map과 Itertaor
- Map에는 iterator()가 없다. keySet(), entrySet(), values()를 호출해야함
예)
	Map map = new HashMap();
		...
	Iterrator it = map.entrySet().iterator();