ch 6-1 객체지향 언어 (6장과 7장이 제일 중요함!)
'80년 초 소프트웨어의 위기 - 빠른 변화를 못 쫓아감
해결책으로 객체지향 언어를 도입(절차적 -> 객체지향)
코드의 재사용성이 높고 유지보수가 용이, 중복 코드 제거
객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙)

객체지향언어(Object Oriented Programming)의 핵심적인 4가지
1. 캡슐화
2. 상속
3. 추상화
4. 다형성
-----------------------------------------------------------------------------
ch6-2 클래스와 객체
Q. 클래스가 왜 필요한가? (한마디로 설계도라고 생각하면됨)
A. 객체를 생성하기 위해 (객체는 제품이라고 생각하면 됨)

Q. 객체가 왜 필요한가?
A. 객체를 사용하기 위해

Q. 객체를 사용한다는 것은?
A. 객체가 가진 속성(변수) 과 기능(메서드) 을 사용 하려고

클래스의 정의 : 객체를 정의해 놓은 것
클래스의 용도 : 객체를 생성하는데 사용

객체의 정의 : 실제로 존재하는 것. 사물 또는 개념
객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

   클래스		객체
제품 설계도	제품
TV 설계도	TV
붕어빵 기계 	붕어빵
-----------------------------------------------------------------------------
ch6-3 객체의 구성요소 - 속성과 기능
객체 = 속성(변수) + 기능(메서드)
속성 : 크기, 길이, 높이, 색상, 볼륨, 채널 등
기능 : 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기
-----------------------------------------------------------------------------
ch6-4 객체와 인스턴스
객체 : 모든 인스턴스를 대표하는 일반적 용어
인스턴스 : 특정 클래스로부터 생성된 객체(예: Tv인스턴스)

          (인스턴스화)
클래스       →        인스턴스(객체)
-----------------------------------------------------------------------------
ch6-5 하나의 소스파일에 여러 클래스 작성

1. (잘된 예) public class가 있는 경우, 소스파일의 이름은 반드시 public class의 이름과 일치해야한다.
Hello2.java
public class Hello2 {}
	class Hello3 {}

2. (잘된 예) public class가 하나도 없는 경우, 소스파일의 이름은 'Hello2.java', 'Hello3.java' 둘다 가능하다.
Hello2.java
class Hello2 {}
class Hello3 {}

3. (잘못된 예) 하나의 소스파일에 둘 이상의 public class가 존재하면 안된다. 각 클래스를 별도의 소스파일에 나눠서 저장하던가, 아니면 둘 중의 한 클래스에 public을 붙이지 않아야 한다.
Hello2.java
public class Hello2 {}
public class Hello3 {}

4. (잘못된 예) 소스파일의 이름이 public class의 이름과 일치하지 않는다. 소스파일의 이름을 'Hello2.java'로 변경해야 맞다.
Hello3.java
public class Hello2 {}
         class Hello3 {}

5. (잘못된 예) 소스파일의 이름과 public, class의 이름이 일치하지 않는다. 대소문자를 구분하므로 대소문자까지 일치해야한다. 그래서, 소스파일의 이름에서 'h'를 'H'로 바꿔야 한다.
hello3.java
public class Hello2 {}
         class Hello3 {}
-----------------------------------------------------------------------------
ch6-6 객체의 생성과 사용
1. 객체의 생성
클래스명 변수명;	// 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명();	// 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;	// Tv클래스 타입의 참조변수 t를 선언
t = new Tv();	// Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장

2. 객체의 사용
t.channel = 7;	// Tv인스턴스의 멤버변수 channel의 값을 7로 한다.
t.channelDown();	// Tv인스턴스의 메서드 chaneelDown()을 호출한다.
System.out.println("현재 채널은 " + t.channel + " 입니다.");

항상 객체를 사용할때에는 아래의 순서대로 사용한다!
클래스(설계도) 작성 → 객체(제품) 생성 → 객체(제품) 사용
class Tv { //Tv 클래스 (설계도)
	// 멤버 변수 3개
	String color;	//색깔
	boolean power;	//전원상태
	int channel;	// 채널

	//메서드 3개
	void power()	{ power = !power; }
	void channelUp()	{ channel++; }
	void channelDown() { channel--; }
}
-----------------------------------------------------------------------------
ch6-7 객체의 생성과 사용 - 예제
Tv t1 = new Tv();
Tv t2 = new Tv();
t1.channel = 7;
System.out.println("t1의 channel값은 " + t1.channel + "입니다.);
System.out.println("t2의 channel값은 " + t2.channel + "입니다.);

GC (가비지 컬렉터) 청소부....? 주기적으로 메모리를 확인하여, 사용할수 없는 객체들을 찾으면 지워준다.

하나의 인스턴스를 여러개의 참조변수가 가리키는 경우 (가능)
여러 인스턴스를 하나의 참조변수가 가리키는 경우 (불가능)
-----------------------------------------------------------------------------
ch6-8 객체배열
객체 배열 == 참조변수 배열
 Tv tv1, tv2, tv3; → Tv[] tvArr = new Tv[3];
Tv[] tvArr = new Tv[3];	// 길이가 3인 Tv타입의 참조변수 배열

//객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

Tv[] tvArr = { new Tv(), new Tv(), new Tv() };

Tv t1 = new Tv();
Tv t2 = new Tv();
Tv t3 = new Tv();

Tv[] tvArr = new Tv[3]; //객체배열 tvArr는 참조변수
tvArr[0] = new Tv(): // 많은 학생들이 이부분을 놓치는 경우가 많으니 반드시 넣을것!!
tvArr[1] = new Tv():
tvArr[2] = new Tv():