ch 6-1 객체지향 언어 (6장과 7장이 제일 중요함!)
'80년 초 소프트웨어의 위기 - 빠른 변화를 못 쫓아감
해결책으로 객체지향 언어를 도입(절차적 -> 객체지향)
코드의 재사용성이 높고 유지보수가 용이, 중복 코드 제거
객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙)

객체지향언어(Object Oriented Programming)의 핵심적인 4가지
1. 캡슐화
2. 상속
3. 추상화
4. 다형성
-----------------------------------------------------------------------------
ch6-2 클래스와 객체
Q. 클래스가 왜 필요한가? (한마디로 설계도라고 생각하면됨)
A. 객체를 생성하기 위해 (객체는 제품이라고 생각하면 됨)

Q. 객체가 왜 필요한가?
A. 객체를 사용하기 위해

Q. 객체를 사용한다는 것은?
A. 객체가 가진 속성(변수) 과 기능(메서드) 을 사용 하려고

클래스의 정의 : 객체를 정의해 놓은 것
클래스의 용도 : 객체를 생성하는데 사용

객체의 정의 : 실제로 존재하는 것. 사물 또는 개념
객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

   클래스		객체
제품 설계도	제품
TV 설계도	TV
붕어빵 기계 	붕어빵
-----------------------------------------------------------------------------
ch6-3 객체의 구성요소 - 속성과 기능
객체 = 속성(변수) + 기능(메서드)
속성 : 크기, 길이, 높이, 색상, 볼륨, 채널 등
기능 : 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기
-----------------------------------------------------------------------------
ch6-4 객체와 인스턴스
객체 : 모든 인스턴스를 대표하는 일반적 용어
인스턴스 : 특정 클래스로부터 생성된 객체(예: Tv인스턴스)

          (인스턴스화)
클래스       →        인스턴스(객체)
-----------------------------------------------------------------------------
ch6-5 하나의 소스파일에 여러 클래스 작성

1. (잘된 예) public class가 있는 경우, 소스파일의 이름은 반드시 public class의 이름과 일치해야한다.
Hello2.java
public class Hello2 {}
	class Hello3 {}

2. (잘된 예) public class가 하나도 없는 경우, 소스파일의 이름은 'Hello2.java', 'Hello3.java' 둘다 가능하다.
Hello2.java
class Hello2 {}
class Hello3 {}

3. (잘못된 예) 하나의 소스파일에 둘 이상의 public class가 존재하면 안된다. 각 클래스를 별도의 소스파일에 나눠서 저장하던가, 아니면 둘 중의 한 클래스에 public을 붙이지 않아야 한다.
Hello2.java
public class Hello2 {}
public class Hello3 {}

4. (잘못된 예) 소스파일의 이름이 public class의 이름과 일치하지 않는다. 소스파일의 이름을 'Hello2.java'로 변경해야 맞다.
Hello3.java
public class Hello2 {}
         class Hello3 {}

5. (잘못된 예) 소스파일의 이름과 public, class의 이름이 일치하지 않는다. 대소문자를 구분하므로 대소문자까지 일치해야한다. 그래서, 소스파일의 이름에서 'h'를 'H'로 바꿔야 한다.
hello3.java
public class Hello2 {}
         class Hello3 {}
-----------------------------------------------------------------------------
ch6-6 객체의 생성과 사용
1. 객체의 생성
클래스명 변수명;	// 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명();	// 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;	// Tv클래스 타입의 참조변수 t를 선언
t = new Tv();	// Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장

2. 객체의 사용
t.channel = 7;	// Tv인스턴스의 멤버변수 channel의 값을 7로 한다.
t.channelDown();	// Tv인스턴스의 메서드 chaneelDown()을 호출한다.
System.out.println("현재 채널은 " + t.channel + " 입니다.");

항상 객체를 사용할때에는 아래의 순서대로 사용한다!
클래스(설계도) 작성 → 객체(제품) 생성 → 객체(제품) 사용
class Tv { //Tv 클래스 (설계도)
	// 멤버 변수 3개
	String color;	//색깔
	boolean power;	//전원상태
	int channel;	// 채널

	//메서드 3개
	void power()	{ power = !power; }
	void channelUp()	{ channel++; }
	void channelDown() { channel--; }
}
-----------------------------------------------------------------------------
ch6-7 객체의 생성과 사용 - 예제
Tv t1 = new Tv();
Tv t2 = new Tv();
t1.channel = 7;
System.out.println("t1의 channel값은 " + t1.channel + "입니다.);
System.out.println("t2의 channel값은 " + t2.channel + "입니다.);

GC (가비지 컬렉터) 청소부....? 주기적으로 메모리를 확인하여, 사용할수 없는 객체들을 찾으면 지워준다.

하나의 인스턴스를 여러개의 참조변수가 가리키는 경우 (가능)
여러 인스턴스를 하나의 참조변수가 가리키는 경우 (불가능)
-----------------------------------------------------------------------------
ch6-8 객체배열
객체 배열 == 참조변수 배열
 Tv tv1, tv2, tv3; → Tv[] tvArr = new Tv[3];
Tv[] tvArr = new Tv[3];	// 길이가 3인 Tv타입의 참조변수 배열

//객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

Tv[] tvArr = { new Tv(), new Tv(), new Tv() };

Tv t1 = new Tv();
Tv t2 = new Tv();
Tv t3 = new Tv();

Tv[] tvArr = new Tv[3]; //객체배열 tvArr는 참조변수
tvArr[0] = new Tv(): // 많은 학생들이 이부분을 놓치는 경우가 많으니 반드시 넣을것!!
tvArr[1] = new Tv():
tvArr[2] = new Tv():
-----------------------------------------------------------------------------
ch6-9 클래스의 정의(1)
 클래스 == 데이터 + 함수

클래스는 1. 설계도 2. 데이터 + 함수 3. 사용자 정의 타입 으로 볼수있다.

1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
3. 구조체 : 서로 관련된 여러 데이터(종류 관계X)를 하나로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합(구조체 + 함수)
-----------------------------------------------------------------------------
ch6-10 클래스의 정의(2)
 사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다.

class Time{
	int hour;
	int minute;
	int second;
}

예시1)
클래스 사용 전
int hour;
int minute;
int second;

클래스 사용 후
Time t = new Time();

예시2)
클래스 사용 전
int hour1, hour2, hour3;
int minute1, minute2, minute3;
int second1, second2, second3;

클래스 사용 후
Time t1 = new Time();
Time t2 = new Time();
Time t3 = new Time();

예시3)
클래스 사용 전
int[] hour = new int[3]; 
int[] minute= new int[3];
int[] second= new int[3];

클래스 사용 후
Time[] t = new Time[3];
t[0] = new Time();
t[1] = new Time();
t[2] = new Time();

만약 12시 34분 56초를 저장하고 싶다?
클래스를 사용하지 않으면 이렇게... (비 객체지향적인 코드)
int hour = 12;
int minute = 34;
int second = 56;

클래스를 사용하면 (객체지향적인 코드)
Time t = new Time();
t.hour = 12;
t.minute = 34;
t.second = 56;
-----------------------------------------------------------------------------
ch6-11 선언위치에 따른 변수(타입)의 종류
class Variables //클래스 영역 (선언문만 가능)
{
	int iv;	//인스턴스 변수 (변수 선언)
	static int cv;	//클래스 변수(static변수, 공유변수)

	void method() //메서드 영역 (메소드 선언)
	{
		int lv = 0;		//지역변수 (Local Variable) (메서드 종료시 자동 제거)
	}
}

변수의 종류	선언 위치			생성 시기
클래스 변수	클래스 영역		클래스가 메모리에 올라갈 때
인스턴스 변수	클래스 영역		인스턴스가 생성되었을 때(제일 중요)
지역변수		클래스 영역 이외의 영역	변수 선언문이 수행되었을 때

클래스 변수는 객체생성 필요없지만, 인스턴스 변수는 객체생성이 필요하다.
쉽게 설명하자면, cv는 아무때나 사용하면 되지만, iv는 객체생성을 해야 iv가 만들어지기때문에 객체 생성 후, 사용가능

객체는 iv변수 묶음이며, 클래스 변수는 객체생성 필요없음 iv는 인스턴스가 생성될때 생성된다.
-----------------------------------------------------------------------------
ch6-12 클래스 변수와 인스턴스 변수
선언위치
영역 - 클래스영역 : iv, cv
         메서드 영역 : lv

예) 카드에서 숫자, 무늬, 폭, 높이 라는 속성이 있으며, 숫자랑 무늬는 개별속성으로 이루어져야한다. (객체마다 다르게 유지되어야 함) 높이랑 폭은 모든 객체공통

class Card {
	String kind;	//무늬 (개별 속성) (iv)
	int number;	//숫자 (개별 속성) (iv)

	static int width = 100; //폭 (공통 속성) (cv)
	static int height = 250; //높이 (공통 속성) (cv)
}

Crad c = new Card(); //객체 생성
c.kind = "HEART";	//객체 사용
c.number = 5;	//객체 사용
Card.width = 200;	//객체 사용, 공통속성 같은경우에는 이렇게 작성하는게 Best
Card.height = 300;	//객체 용, 공통속성 같은경우에는 이렇게 작성하는게 Best
-----------------------------------------------------------------------------
ch6-13 클래스 변수 (예제)
-----------------------------------------------------------------------------
ch6-14 메서드란?
1. 문장들을 묶어놓은 것.
- 작업 단위로 문장들의 묶어서 이름 붙인 것

2. 값(입력)을 받아서 처리하고, 결과를 반환(출력)
int add(int x, int y) { //int는 반환타입(출력), add는 메서드 이름, x와 y는 매개변수선언 (입력)
	int result = x + y;

	return result; //결과를 반환
}

메서드는 class안에 있어야하고, 함수는 독립적인 존재이며 메서드랑 함수는 근본적으로는 같다!

메서드의 장점
- 코드의 중복을 줄일 수 있다.
- 코드의 관리가 쉽다.
- 코드를 재사용할 수 있다.
- 코드가 간결해서 이해하기 쉬워진다.

메서드의 작성
- 반복적으로 수행되는 여러 문장을 메서드로 작성

메서드 = 선언부 + 구현부
반환타입 메서드 이름 (타입 변수명, 타입 변수명, ...) //선언부
{
	//메서드 호출 시 수행될 코드 (구현부)
}

int add(int a, int b) //반환 타입이 없을경우 int가 아닌 void로 수정
{
	int result = a + b;
	return result;	// 호출한 메서드로 결과를 반환한다.
}
-----------------------------------------------------------------------------
ch6-15 메서드의 구현부
지역변수(lv) : 메서드 내에 선언된 변수

int add(int x, int y) {	//메서드 영역
	int result = x + y;	//메서드 영역
	return result;	//메서드 영역
}

int multiply(int x, int y) {	//메서드 영역
	int result = x * y;	//메서드 영역
	return result;	//메서드 영역
}
-----------------------------------------------------------------------------
ch6-16 메서드의 구현부 (예제)
-----------------------------------------------------------------------------
ch6-17 메서드의 호출
메서드를 불러다가 작업을 하는것!
메서드이름(값1, 값2, ...);	//메서드를 호출하는 방법

print99danAll();	// void print99danAll()을 호출, 반환타입이 void이므로 출력이 없다. 내가 작업을 하고 결과를 줄것이 없다!
int result = add(3, 5);	//int add(int x, int y)를 호출하고, 결과를 result에 저장
-----------------------------------------------------------------------------
ch6-18 메서드의 실행흐름
MyMath mm = new MyMath();	//먼저 인스턴스를 생성한다.
long value = mm.add(1L, 2L);	//메서드를 호출한다.

long add(long a, long b) {
	long result = a + b;
	return result;
}

1. main 메서드에서 메서드 add를 호출한다. 인수1L과 2L이 메서드 add의 매개변수 a, b에 각각 복사(대입)된다.
2. 메서드 add의 괄호{}안에 있는 문장들이 순서대로 수행된다.
3. 메서드 add의 모든 문장이 실행되거나 return문을 만나면, 호출한 메서드(main 메서드)로 되돌아 와서 이후의 문장들을 실행한다.
-----------------------------------------------------------------------------
ch6-19 메서드의 실행흐름 (예제)
-----------------------------------------------------------------------------
ch6-20 return문
실행 중인 메서드를 종료하고 호출한 곳으로 되돌아간다.

void printGugudan(int dan) {
	if(!(2 <= dan && dan <= 9))
		return;	//dan의 값이 2~9가 아닌경우, 호출한 곳으로 그냥 되돌아 간다.

	for(int i=1; i<=9; i++) {
		System.out.printf("%d * %d = %d\n", dan, i, dan * i);
	}
	return;	//반환 타입이 void이므로 생략 가능, 컴파일러가 자동추가
}

반환타입이 void가 아닌 경우, 반드시 return문 필요
int multiply(int x, int y) {
	int result = x * y;
	return result;	// 반환 타입이 void가 아니므로 생략불가
}

int max(int a, int b)	 {
	if(a < b)
		return a; //조건식이 참일 때만 실행된다.
	else
		return b; //조건식이 거짓일 때 실행된다.
}
-----------------------------------------------------------------------------
ch6-21 반환값
반환타입이 void가 아닐때
int add(int x, int y) {		int add(int x, int y) {
	int result = x + y;			return x + y;
	return result;		}
}

int result = mm.add(3, 5);
	int add(int x, int y) {
		return x + y;
	}
-----------------------------------------------------------------------------
ch6-22 호출 스택(call stack) (제일 중요하며, 이걸 이해하지 못하면 다음 진도부터 차질이 생김!!)
 스택(stack): 밑이 막힌 상자. 위에 차곡차곡 쌓인다.
메서드 수행에 필요한 메모리가 제공되는 공간
메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제

아래 있는 메서드가 위의 메서드를 호출한 것
맨 위의 메서드 하나만 실행 중, 나머 지는 대기중
-----------------------------------------------------------------------------
ch6-23 기본형 매개변수
기본형 매개변수 - 변수의 값을 읽기만 할 수 있다.(read only)
참조형 매개변수 - 변수의 값을 읽고 변경할 수 잇다.(read & write)
-----------------------------------------------------------------------------
ch6-24 참조형 매개변수
기본형 매개변수 - 변수의 값을 읽기만 할 수 있다.(read only)
참조형 매개변수 - 변수의 값을 읽고 변경할 수 잇다.(read & write)
